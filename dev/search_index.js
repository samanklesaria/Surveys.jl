var documenterSearchIndex = {"docs":
[{"location":"#Surveys.jl","page":"Surveys.jl","title":"Surveys.jl","text":"A Julia package for design-based inference in survey sampling. This package provides functionality comparable to R's survey package, with native Julia performance and integration with DataFrames.jl.","category":"section"},{"location":"#Overview","page":"Surveys.jl","title":"Overview","text":"Surveys.jl implements methods for analyzing data from complex survey designs, including:\n\nSimple random sampling (SRS)\nStratified sampling\nOne-stage cluster sampling\nTwo-stage cluster sampling\nTaylor series variance estimation\n\nThe main exported type is SampleSum, which stores both an estimate and its variance. ","category":"section"},{"location":"#Simple-Random-Sampling","page":"Surveys.jl","title":"Simple Random Sampling","text":"For simple random sampling without replacement, use π_sum with the finite population correction (FPC).\n\nJulia:\n\nusing Surveys, DataFramesMeta\nresult = @combine(apisrs, :total = π_sum(:enroll, N))\n\nR equivalent:\n\nlibrary(survey)\nsrs_design <- svydesign(id=~1, fpc=~fpc, data=apisrs)\nsvytotal(~enroll, srs_design)\n\nThe π_sum function computes the Horvitz-Thompson estimator for the total and its variance, accounting for the finite population correction.","category":"section"},{"location":"#Stratified-Sampling","page":"Surveys.jl","title":"Stratified Sampling","text":"For stratified sampling, compute subtotals within each stratum, then combine them.\n\nJulia:\n\nstrat_result = @chain apistrat begin\n    @groupby(:stype)\n    @combine(:subtotal = π_sum(:enroll, Int(:fpc[1])))\n    @combine(:total = sum(:subtotal))\nend\n\nR equivalent:\n\nstrat_design <- svydesign(id=~1, fpc=~fpc, strata=~stype, data=apistrat)\nsvytotal(~enroll, strat_design)\n\nThe SampleSum type supports addition, so stratified estimates can be combined by summing the subtotal column.","category":"section"},{"location":"#One-Stage-Cluster-Sampling","page":"Surveys.jl","title":"One-Stage Cluster Sampling","text":"For one-stage cluster sampling, first aggregate within clusters, then use π_sum on the cluster totals.\n\nJulia:\n\ngdf = groupby(cal_crime, :county)\n@chain gdf begin\n    @combine(:subtotal = sum(:Burglary))\n    @combine(:total = π_sum(:subtotal, N_counties))\nend\n\nR equivalent:\n\nstage1_design <- svydesign(id=~county, fpc=~fpc, data=cal_crime)\nsvytotal(~Burglary, stage1_design)\n\nThe key is to first compute totals within each sampled cluster, then treat those cluster totals as the observations for π_sum.","category":"section"},{"location":"#Two-Stage-Cluster-Sampling","page":"Surveys.jl","title":"Two-Stage Cluster Sampling","text":"For two-stage sampling, apply π_sum twice: once within primary sampling units (PSUs), then across PSUs.\n\nJulia:\n\n@chain df begin\n    @groupby(:county)\n    @combine(:subtotal = π_sum(:Burglary, county_sizes[first(:county)]))\n    @combine(:total = π_sum(:subtotal, N_counties))\nend\n\nR equivalent:\n\nstage2_design <- svydesign(id=~county+id, fpc=~fpc+fpc2, data=df)\nsvytotal(~Burglary, stage2_design)\n\nThe variance calculation properly accounts for both stages of sampling through the nested application of π_sum.","category":"section"},{"location":"#Ratio-Estimation","page":"Surveys.jl","title":"Ratio Estimation","text":"For ratio estimation or other nonlinear functions of totals, use π_sum with a Function argument for Taylor series linearization.\n\nJulia:\n\n# Estimate ratio of api.stu to enroll\nratio_result = @combine(apisrs, :total = \n    π_sum((a -> a[1] / a[2]), [:api_stu :enroll], Int(:fpc[1])))\n\nR equivalent:\n\nsrs_design <- svydesign(id=~1, fpc=~fpc, data=apisrs)\nsvyratio(~api.stu, ~enroll, srs_design)\n\nThe π_sum function uses automatic differentiation to compute the Taylor series approximation to the variance of nonlinear estimators.","category":"section"},{"location":"#Linearization-with-Stratification-and-Clustering","page":"Surveys.jl","title":"Linearization with Stratification and Clustering","text":"When π_sum is passed a Matrix instead of a Vector, it creates a SampleSums object instead. This can be passed to sum or π_sum to get clustered or stratified Taylor series variance estimates. \n\nJulia:\n\n@chain apistrat begin\n    @groupby(:stype)\n    @combine(:subtotal=π_sum([:api_stu :enroll],  Int(:fpc[1])))\n    @combine(:total=sum(a->a[1] / a[2], :subtotal))\nend\n\nstrat_design <- svydesign(id=~1, fpc=~fpc, strata=~stype, data=apistrat)\nsvyratio(~api.stu, ~enroll, strat_design)","category":"section"},{"location":"#API-Reference","page":"Surveys.jl","title":"API Reference","text":"","category":"section"},{"location":"#Surveys.SampleSum","page":"Surveys.jl","title":"Surveys.SampleSum","text":"struct SampleSum\n\nsum::Float64: Point estimate (e.g., estimated total, mean, or ratio)\nvar::Float64: Variance of the estimate\n\nPopulation estimate and its variance.\n\n\n\n\n\n","category":"type"},{"location":"#Surveys.SampleSums","page":"Surveys.jl","title":"Surveys.SampleSums","text":"struct SampleSums\n\nsums_M::Vector{Float64}: Estimates of population totals for each variable\nsamples_nM::Matrix{Float64}: Sample x variable matrix of observations\nN::Int64: Population size\n\nMultivariate population estimates. These are usually collapsed into a SampleSum using sum(f::Function, xs) for stratified studies or π_sum(f::Function, xs) for cluster studies.\n\n\n\n\n\n","category":"type"},{"location":"#Surveys.pwr_sum-Tuple{AbstractVector{<:Real}, Vector{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.pwr_sum","text":"pwr_sum(\n    xs::AbstractVector{<:Real},\n    probs::Vector{<:Real},\n    N::Int64\n) -> SampleSum\n\n\nProbability-weighted ratio estimator (Hansen-Hurwitz estimator) for sampling with replacement.\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.pwr_sum-Tuple{AbstractVector{SampleSum}, AbstractVector{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.pwr_sum","text":"pwr_sum(\n    xs::AbstractVector{SampleSum},\n    probs::AbstractVector{<:Real},\n    N::Int64\n) -> SampleSum\n\n\nCombine cluster estimates using probability-weighted ratio estimation.\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_lm-Tuple{StatsModels.FormulaTerm, Any, AbstractVector{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.π_lm","text":"π_lm(\n    f::StatsModels.FormulaTerm,\n    df,\n    probs::AbstractVector{<:Real},\n    N::Int64\n) -> SampleSum\n\n\nFit a weighted linear regression model with unequal probability sampling.\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_lm-Tuple{StatsModels.FormulaTerm, Any, Int64}","page":"Surveys.jl","title":"Surveys.π_lm","text":"π_lm(f::StatsModels.FormulaTerm, df, N::Int64) -> SampleSum\n\n\nFit a linear regression model accounting for survey design (simple random sampling).\n\nSee also\n\nR's survey::svyglm()\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, Matrix, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(\n    xs::AbstractVector{<:Real},\n    probs::AbstractVector{<:Real},\n    joint_probs::Matrix,\n    N::Int64\n) -> SampleSum\n\n\nHorvitz-Thompson estimator for a sample xs from a population with size N with arbitrary inclusion probabilities probs and pairwise inclusion probabilities joint_probs.\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{AbstractVector{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(xs::AbstractVector{<:Real}, N::Int64) -> SampleSum\n\n\nCompute the Horvitz-Thompson estimate of a total for simple random samples xs without replacement from a population of size N.\n\nSee also R's survey::svytotal() with svydesign(id=~1, fpc=~fpc)\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{AbstractVector{SampleSum}, AbstractVector{<:Real}, Matrix, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(\n    xs::AbstractVector{SampleSum},\n    probs::AbstractVector{<:Real},\n    joint_probs::Matrix,\n    N::Int64\n)\n\n\nCombine cluster estimates with unequal probability sampling.\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{AbstractVector{SampleSum}, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(xs::AbstractVector{SampleSum}, N::Int64) -> SampleSum\n\n\nCombine cluster-level estimates for multi-stage sampling designs.\n\nThis is used for cluster sampling or multi-stage designs where you have already computed estimates within each sampled cluster. The variance properly accounts for clustering.\n\nExamples\n\n# Two-stage sampling: compute within-cluster totals, then aggregate\ncluster_totals = [π_sum(cluster1_data, n1), π_sum(cluster2_data, n2)]\noverall_total = π_sum(cluster_totals, N_clusters)\n\nSee also\n\nR's survey::svydesign() with id=~cluster\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{Function, Matrix{<:Real}, AbstractVector{<:Real}, Matrix, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(\n    f::Function,\n    xs::Matrix{<:Real},\n    probs::AbstractVector{<:Real},\n    joint_probs::Matrix,\n    N::Int64\n) -> SampleSum\n\n\nEstimate a nonlinear function of totals using Taylor series linearization with unequal probability sampling.\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{Function, Matrix{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(\n    f::Function,\n    xs::Matrix{<:Real},\n    N::Int64\n) -> SampleSum\n\n\nEstimate a nonlinear function of totals using Taylor series linearization for simple random sampling.\n\n\n\n\n\n","category":"method"}]
}

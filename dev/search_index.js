var documenterSearchIndex = {"docs":
[{"location":"#Surveys.jl","page":"Surveys.jl","title":"Surveys.jl","text":"A Julia package for design-based inference in survey sampling. This package provides functionality comparable to R's survey package, with native Julia performance and integration with DataFrames.jl.","category":"section"},{"location":"#Overview","page":"Surveys.jl","title":"Overview","text":"Surveys.jl implements methods for analyzing data from complex survey designs, including:\n\nSimple random sampling (SRS)\nStratified sampling\nOne-stage cluster sampling\nTwo-stage cluster sampling\nTaylor series variance estimation\n\nThe main exported type is SampleSum, which stores both an estimate and its variance. The package provides the π_sum function for computing totals under various sampling designs.","category":"section"},{"location":"#Simple-Random-Sampling","page":"Surveys.jl","title":"Simple Random Sampling","text":"For simple random sampling without replacement, use π_sum with the finite population correction (FPC).\n\nJulia:\n\nusing Surveys, DataFramesMeta\nresult = @combine(apisrs, :total = π_sum(:enroll, N))\n\nR equivalent:\n\nlibrary(survey)\nsrs_design <- svydesign(id=~1, fpc=~fpc, data=apisrs)\nsvytotal(~enroll, srs_design)\n\nThe π_sum function computes the Horvitz-Thompson estimator for the total and its variance, accounting for the finite population correction.","category":"section"},{"location":"#Stratified-Sampling","page":"Surveys.jl","title":"Stratified Sampling","text":"For stratified sampling, compute subtotals within each stratum, then combine them.\n\nJulia:\n\nstrat_result = @chain apistrat begin\n    @groupby(:stype)\n    @combine(:subtotal = π_sum(:enroll, Int(:fpc[1])))\n    @combine(:total = sum(:subtotal))\nend\n\nR equivalent:\n\nstrat_design <- svydesign(id=~1, fpc=~fpc, strata=~stype, data=apistrat)\nsvytotal(~enroll, strat_design)\n\nThe SampleSum type supports addition, so stratified estimates can be combined by summing the subtotal column.","category":"section"},{"location":"#One-Stage-Cluster-Sampling","page":"Surveys.jl","title":"One-Stage Cluster Sampling","text":"For one-stage cluster sampling, first aggregate within clusters, then use π_sum on the cluster totals.\n\nJulia:\n\ngdf = groupby(cal_crime, :county)\n@chain gdf begin\n    @combine(:subtotal = sum(:Burglary))\n    @combine(:total = π_sum(:subtotal, N_counties))\nend\n\nR equivalent:\n\nsvydesign(id=~county, fpc=~fpc, data=cal_crime)\nsvytotal(~Burglary, cluster1_design)\n\nThe key is to first compute totals within each sampled cluster, then treat those cluster totals as the observations for π_sum.","category":"section"},{"location":"#Two-Stage-Cluster-Sampling","page":"Surveys.jl","title":"Two-Stage Cluster Sampling","text":"For two-stage sampling, apply π_sum twice: once within primary sampling units (PSUs), then across PSUs.\n\nJulia:\n\n@chain stage2 begin\n    @groupby(:county)\n    @combine(:subtotal = π_sum(:Burglary, county_sizes[first(:county)]))\n    @combine(:total = π_sum(:subtotal, N_counties))\nend\n\nR equivalent:\n\nstage2_design <- svydesign(id=~county+id, fpc=~fpc+fpc2, data=stage2)\nsvytotal(~Burglary, stage2_design)\n\nThe variance calculation properly accounts for both stages of sampling through the nested application of π_sum.","category":"section"},{"location":"#Ratio-Estimation","page":"Surveys.jl","title":"Ratio Estimation","text":"For ratio estimation or other nonlinear functions of totals, use apply_π_sum with Taylor series linearization.\n\nJulia:\n\n# Estimate ratio of api.stu to enroll\nratio_result = @combine(apisrs, :total = \n    apply_π_sum((a -> a[1] / a[2]), [:api_stu :enroll], Int(:fpc[1])))\n\nR equivalent:\n\nsvyratio(~api.stu, ~enroll, srs_design)\n\nThe apply_π_sum function uses automatic differentiation to compute the Taylor series approximation to the variance of nonlinear estimators.","category":"section"},{"location":"#API-Reference","page":"Surveys.jl","title":"API Reference","text":"","category":"section"},{"location":"#Surveys.SampleSum","page":"Surveys.jl","title":"Surveys.SampleSum","text":"SampleSum\n\nA structure containing a point estimate and its variance for survey statistics.\n\nFields\n\nsum::Float64: The point estimate (e.g., estimated total, mean, or ratio)\nvar::Float64: The variance of the estimate\n\nExamples\n\n# Create a sample sum\nest = SampleSum(1000.0, 25.0)\n\n# Combine estimates from two strata\ntotal = SampleSum(500.0, 10.0) + SampleSum(500.0, 15.0)\n\n# Get confidence interval\nconfint(est)\n\n\n\n\n\n","category":"type"},{"location":"#Surveys.apply_π_sum-Tuple{Function, Matrix{<:Real}, AbstractVector{<:Real}, Matrix, Int64}","page":"Surveys.jl","title":"Surveys.apply_π_sum","text":"apply_π_sum(f::Function, xs::Matrix{<:Real}, probs::AbstractVector{<:Real}, joint_probs::Matrix, N::Int) -> SampleSum\n\nEstimate a nonlinear function of totals using Taylor series linearization with unequal probability sampling.\n\nArguments\n\nf: Function to apply to the vector of population totals\nxs: Matrix where each column represents a variable\nprobs: Vector of inclusion probabilities\njoint_probs: Matrix of joint inclusion probabilities\nN: Population size\n\nReturns\n\nA SampleSum with the estimated value of f and its variance via the delta method.\n\nDetails\n\nUses automatic differentiation to compute the gradient of f, then applies the delta method: Var(f(T̂)) ≈ ∇f' × Var(T̂) × ∇f\n\nExamples\n\n# Ratio estimator with unequal probabilities\napply_π_sum(x -> x[1]/x[2], [numerator denominator], probs, joint_probs, N)\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.apply_π_sum-Tuple{Function, Matrix{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.apply_π_sum","text":"apply_π_sum(f::Function, xs::Matrix{<:Real}, N::Int) -> SampleSum\n\nEstimate a nonlinear function of totals using Taylor series linearization for simple random sampling.\n\nArguments\n\nf: Function to apply to the vector of population totals\nxs: Matrix where each column represents a variable (rows are observations)\nN: Population size\n\nReturns\n\nA SampleSum with the estimated value of f and its variance computed via the delta method.\n\nDetails\n\nUses automatic differentiation (ForwardDiff.jl) to compute gradients, avoiding manual derivation. The variance is approximated using first-order Taylor expansion.\n\nExamples\n\n# Estimate ratio of two variables\ndata = [api_stu enroll]  # n×2 matrix\nratio = apply_π_sum(x -> x[1]/x[2], data, N)\n\n# Coefficient of variation\ncv = apply_π_sum(x -> sqrt(x[2] - x[1]^2/N)/x[1], [totals totals_sq], N)\n\nSee also\n\nR's survey::svyratio(), survey::svycontrast()\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.pwr_sum-Tuple{AbstractVector{<:Real}, Vector{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.pwr_sum","text":"pwr_sum(xs::AbstractVector{<:Real}, probs::Vector{<:Real}, N::Int) -> SampleSum\n\nProbability-weighted ratio estimator (Hansen-Hurwitz estimator) for sampling with replacement.\n\nArguments\n\nxs: Vector of observations from the sample\nprobs: Vector of selection probabilities\nN: Population size\n\nReturns\n\nA SampleSum with the weighted estimate and its variance.\n\nDetails\n\nComputes the estimator: T̂ = mean(xᵢ/pᵢ) with variance Var(T̂) = var(xᵢ/pᵢ)/n\n\nThis is appropriate for sampling with replacement or when joint inclusion probabilities are unknown. It is generally less efficient than the Horvitz-Thompson estimator but simpler to compute.\n\nExamples\n\n# Sampling with replacement with known selection probabilities\npwr_sum(sample_data, selection_probs, N)\n\nSee also\n\nπ_sum for sampling without replacement\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.pwr_sum-Tuple{AbstractVector{SampleSum}, AbstractVector{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.pwr_sum","text":"pwr_sum(xs::AbstractVector{SampleSum}, probs::AbstractVector{<:Real}, N::Int) -> SampleSum\n\nCombine cluster estimates using probability-weighted ratio estimation.\n\nArguments\n\nxs: Vector of SampleSum objects from sampled clusters\nprobs: Vector of cluster selection probabilities\nN: Population size\n\nReturns\n\nA SampleSum combining cluster-level estimates with variance.\n\nDetails\n\nUsed for multi-stage designs where clusters are sampled with replacement or when joint inclusion probabilities are unavailable.\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_lm-Tuple{StatsModels.FormulaTerm, Any, AbstractVector{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.π_lm","text":"π_lm(f::FormulaTerm, df, probs::AbstractVector{<:Real}, N::Int) -> SampleSum\n\nFit a weighted linear regression model with unequal probability sampling.\n\nArguments\n\nf: Formula specifying the model\ndf: DataFrame containing the variables\nprobs: Vector of inclusion probabilities\nN: Population size\n\nReturns\n\nA SampleSum with regression coefficients and design-based covariance matrix.\n\nDetails\n\nFits a weighted least squares model where weights are inverse inclusion probabilities, with variance accounting for the sampling design.\n\nExamples\n\nmodel = π_lm(@formula(y ~ x), data, inclusion_probs, N)\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_lm-Tuple{StatsModels.FormulaTerm, Any, Int64}","page":"Surveys.jl","title":"Surveys.π_lm","text":"π_lm(f::FormulaTerm, df, N::Int) -> SampleSum\n\nFit a linear regression model accounting for survey design (simple random sampling).\n\nArguments\n\nf: Formula specifying the model (e.g., @formula(y ~ x1 + x2))\ndf: DataFrame containing the variables\nN: Population size\n\nReturns\n\nA SampleSum containing regression coefficients and their covariance matrix.\n\nDetails\n\nComputes design-based variance estimates for regression coefficients using the finite population correction. Uses heteroskedasticity-robust variance estimation.\n\nExamples\n\nusing StatsModels\nmodel = π_lm(@formula(income ~ age + education), survey_data, N)\n\nSee also\n\nR's survey::svyglm()\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, Matrix, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(xs::AbstractVector{<:Real}, probs::AbstractVector{<:Real}, joint_probs::Matrix, N::Int) -> SampleSum\n\nHorvitz-Thompson estimator with arbitrary inclusion probabilities.\n\nArguments\n\nxs: Vector of observations from the sample\nprobs: Vector of first-order inclusion probabilities (πᵢ)\njoint_probs: Matrix of second-order inclusion probabilities (πᵢⱼ)\nN: Population size\n\nReturns\n\nA SampleSum with the estimated total and its variance using the full Horvitz-Thompson variance.\n\nDetails\n\nUses the unbiased variance estimator: Var(T̂) = Σᵢ Σⱼ (πᵢⱼ - πᵢπⱼ) / πᵢⱼ × (yᵢ/πᵢ) × (yⱼ/πⱼ)\n\nThis is appropriate for unequal probability sampling without replacement.\n\nExamples\n\n# Probability proportional to size sampling\nπ_sum(sample_values, inclusion_probs, joint_inclusion_probs, N)\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{AbstractVector{<:Real}, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(xs::AbstractVector{<:Real}, N::Int) -> SampleSum\n\nCompute the Horvitz-Thompson estimate of a population total for simple random sampling without replacement.\n\nArguments\n\nxs: Vector of observations from the sample\nN: Population size (finite population correction)\n\nReturns\n\nA SampleSum containing the estimated total and its variance.\n\nDetails\n\nComputes the estimator T̂ = N * mean(xs) with variance: Var(T̂) = N² × (1/n - 1/N) × s²\n\nwhere n is the sample size and s² is the sample variance.\n\nExamples\n\n# Sample 100 observations from population of 1000\nsample_data = [12.5, 15.3, 10.2, ...]  # length 100\ntotal_est = π_sum(sample_data, 1000)\n\nSee also\n\nR's survey::svytotal() with svydesign(id=~1, fpc=~fpc)\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{AbstractVector{SampleSum}, AbstractVector{<:Real}, Matrix, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(xs::AbstractVector{SampleSum}, probs::AbstractVector{<:Real}, joint_probs::Matrix, N::Int) -> SampleSum\n\nCombine cluster estimates with unequal probability sampling.\n\nArguments\n\nxs: Vector of SampleSum objects from sampled clusters\nprobs: Vector of cluster selection probabilities\njoint_probs: Matrix of joint selection probabilities\nN: Total number of clusters in population\n\nReturns\n\nA SampleSum accounting for unequal probability cluster sampling with within-cluster variation.\n\n\n\n\n\n","category":"method"},{"location":"#Surveys.π_sum-Tuple{AbstractVector{SampleSum}, Int64}","page":"Surveys.jl","title":"Surveys.π_sum","text":"π_sum(xs::AbstractVector{SampleSum}, N::Int) -> SampleSum\n\nCombine cluster-level estimates for multi-stage sampling designs.\n\nArguments\n\nxs: Vector of SampleSum objects, one per sampled cluster\nN: Total number of clusters in the population\n\nReturns\n\nA SampleSum with the combined estimate and variance accounting for both between-cluster and within-cluster variation.\n\nDetails\n\nThis is used for cluster sampling or multi-stage designs where you have already computed estimates within each sampled cluster. The variance properly accounts for clustering.\n\nExamples\n\n# Two-stage sampling: compute within-cluster totals, then aggregate\ncluster_totals = [π_sum(cluster1_data, n1), π_sum(cluster2_data, n2)]\noverall_total = π_sum(cluster_totals, N_clusters)\n\nSee also\n\nR's survey::svydesign() with id=~cluster\n\n\n\n\n\n","category":"method"}]
}
